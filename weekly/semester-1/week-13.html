<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Creative Process Journal, 24-25.</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <link rel="icon" type="image/svg+xml" href="/favicon.png" />
    <link rel="stylesheet" type="text/css" href="/css/styles.css" />
  </head>

  <body>
    <header>
      <nav class="main__nav-bar">
        <ul class="main__nav-title">
          <li><a href="/">IxD-ID</a></li>
          <li class="mobile__hide padding__top-xs"><a href="/about"><img height="12rem" src="/assets/images/CHOIYERIN_black.png" alt=""></a></li>
        </ul>
        <ul class="main__nav-list">
          <li class="main__nav-item"><a href="/">process-journal</a></li>
           <li class="main__nav-item"><a href="/making/index.html">catalogue-of-making</a></li>
          <li class="main__nav-item"><a href="/repository">repository</a></li>
          <li class="main__nav-about">
            <p>
              A design communication graduation project.
            </p>
          </li>
        </ul>
        <div class="main__nav-ham">
          <span class="main__nav-ham-bar"></span>
          <span class="main__nav-ham-bar"></span>
        </div>
      </nav>
    </header>

    <main>
      <article>
        <section id="title-section">
          <div class="row width__l margin__auto padding__top-xl">
            <div class="column__half type__content padding__top-m ">
              <h1>13 Get Back <br> to Building</h1>
              <p class="padding__top-l">This week, I finally got back to VS code environment, architecturing the tool's internal logic and implementating them. The goal was to translate subjective motion into a manageable system by defining a <b>Hybrid State Structure</b>. Critically, during the iterative building process, I made a major technical decision from Vanilla Javascript to <b>React</b> to ensure that tool has the robust state mangaement required for its complex architecture.</p>
            </div>
            
            <div class="column__no-content"></div>

            <div class="column no-content-above padding__y-m">
              <div class="box__keywords-container">
                <ul class="box__keywords-list">
                  <li class="box__keywords-item"><h5>Week-twelve</h5> 10 ~ 16. Nov, 2025 </li>
                  <li class="box__keywords-item"><h5>Journal-by</h5>Choi Yerin</li>
                  <li class="box__keywords-item"><h5>Keywords</h5>
                    <ul class="keywords-grid">
                      <li class="keywords-circle-b">Tool-Architecture</li>
                      <li class="keywords-circle">React
                      </li>
                      <li class="keywords-circle">State-Management</li> 
                      
                      <li class="keywords-circle-b">Per-Property-Control</li>
                      <li class="keywords-circle">Iterative-Build</li>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
        </section>

        <section id="contents-section" class="row width__l margin__auto padding__y-xl">

          <aside class="sidebar">
            <div class="sidebar-item active" data-target="section1">Transition to React</div>
            <div class="sidebar-item" data-target="section2">State Model</div>
            <div class="sidebar-item" data-target="section3">Code Architecture</div>
            <div class="sidebar-item" data-target="section4">Next-Steps</div>
          </aside>

          <div class="content-wrapper">

            <div id="section1" class="row width__s margin__auto">
              <h2> The Implementation Reality:
                <br>Translation to React</h2>

              <p class="divider-top">The technical ambition of the comprehensive tool quickly exposed the limitations of my earlier approach, forcing a fundamental mid-project pivot.</p>
              
              <div class="black__text-container"> <p>I initially started implementing the new architecture with <b>Vanilla JavaScript</b> (similar to what was used in the simpler prototyp), but the process was too slow and led to significant stability issues. It was taking much longer to write than the earlier <b>Button Parameter Lab</b> and the code was becoming buggy.</p> </div>

              <p>So, I made the necessary decision to pivot to <b>React</b>. Although this imposed a steeper learning curve, it was a better way to achieve the robust state management and component architecture required for a professional tool. I relied on my ongoing self-learning <b class="oblique">(Sololearn app, YouTube tutorials)</b> to execute this transition.</p>

              <h3>Code Translation: From Script to Component</h3>

              <p>The shift to React was essential because the Vanilla JS model relies on manual DOM manipulation and global variables to track state, which quickly becomes messy. React’s <b>component-based</b> model fundamentally solved this, as evidenced in <span class="code-block-orange">SketchElementPage.jsx</span></p>

              <div class="row margin__auto padding__y-m">
                <div class="column">
                    <h3>Code Translation: JS vs. React Architecture</h3>
                  <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; margin-top: 1rem; font-size: 0.9rem;">
                      <thead>
                        <tr style="border-bottom: 2px solid var(--color-link); text-align: left;">
                        <th style="padding: 12px;"><b>Concept</b></th>
                        <th style="padding: 12px; font-weight: 800;"><b>Vanilla JS</b>  <br></th>
                        <th style="padding: 12px; font-weight: 800;"><b>React</b> <br></th>
                        <th style="padding: 12px; font-weight: 800;"><b>Architectural Justification</b></th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr style="border-bottom: 1px solid var(--color-5);">
                            <td style="padding: 12px; vertical-align: top;"><strong>Data/
                            <br>Element List</strong></td>
                            <td style="padding: 12px; vertical-align: top;"><span class="code-block-orange">Global array</span> <span class="code-block-orange">elementsData</span></td>
                            <td style="padding: 12px; vertical-align: top;">Managed by useState hook:<br>
                              <span class="code-block-orange">const [elementsData, setElementsData] = useState([])</span></td>
                            <td style="padding: 12px; vertical-align: top;"><strong>Reactivity:</strong> Changes to the data automatically update the UI (JSX) without manual DOM rendering, drastically reducing bugs.</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--color-5);">
                            <td style="padding: 12px; vertical-align: top;"><strong>Selection State</strong></td>
                            <td style="padding: 12px; vertical-align: top;"> <span class="code-block-orange">Global selectedItems = new Set() with manual checks</span></td>
                            <td style="padding: 12px; vertical-align: top;">Managed by <spanZ>useState</span>:<br> <span class="code-block-orange">const [selectedItems, setSelectedItems] = useState(new Set())</span></td>
                            <td style="padding: 12px; vertical-align: top;"><strong>Stability:</strong> Selection logic is tied cleanly to the component lifecycle.</td>
                          </tr>
                          <tr>
                            <td style="padding: 12px; vertical-align: top;"><strong>UI Updates</strong></td>
                            <td style="padding: 12px;">Manual <br> <span class=" margin__top-m code-block-orange">renderElements()</span> and <br><span class="code-block-orange">innerHTML</span> updates</td>
                            <td style="padding: 12px; vertical-align: top;"><strong>Automatic</strong> via JSX rendering triggered by <br><span class="code-block-orange">setElementsData</span></td>
                            <td style="padding: 12px; vertical-align: top;"><strong>Efficiency:</strong> Enables a clean, declarative model, moving focus from <em>how</em> to draw the DOM to <em>what</em> the state should be.</td>
                          </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>

              
            </div>

            

            <div id="section2" class="row width__s margin__auto padding__top-xl">
              <h2>Information Architecture: <br> Approaches to State Model</h2>
              <p class="divider-top">The true challenge of the prototyping was securing the <b>State Machine Architecture</b> within the new React framework. My extensive planning for button types (Action, Selection, Toggle) quickly revealed that I needed to handle complex, conditional states.</p>

              <h3>The Struggle with Compound States</h3>

              <p>I initially planned to hardcode all compound states (e.g., <span class="code-block-orange">Selected</span> / <span class="code-block-orange">On + Hover</span>, <span class="code-block-orange">Off → On</span>). This level of granularity, while accurate to real-world interaction, was visually overwhelming for the designer and extremely difficult to manage in code, confirming the gap identified in the <b>Figma/HANA analysis</b>.</p>

              <div class="row">
                <div class="column"><img class="orange-border" src="/assets/images/figma-interface.jpg" alt=""><figcaption class="margin__top-s"><p>Trigger options (Figma)</p></figcaption></div>
                <div class="column"><img class="orange-border" src="/assets/images/hana-interface-2.jpg" alt=""><figcaption class="margin__top-s"><p>Event options (HANA/Spline)</p></figcaption></div>
                
              </div>

              <h3>The Hybrid Solution</h3>
              <p>I finalized with the <b>Hybrid State Model</b> by moving complexity away <br>from the state name and into the component's conditional logic:</p>

              <video class="lazy orange-border" autoplay loop muted playsinline preload="none" src="/assets/videos/sketch-button-process1-hybrid.mp4"></video>
              <figcaption><p>Prototype Process Demo for the dynamic state & Button Types names</p>
              </figcaption>

              <div class="bg__text-container">
                  <li class="bulletpoints"><p><b>Conditional Parameters:</b> <br>I added helper functions and state properties that govern behavior, such as stayInReleasedState (for toggle/selection buttons) and logic to override Hover during Pressed or Released states. This simplifies the visible state list while preserving the necessary parametric depth.</p></li>
              </div>

              <div class="bg__text-container">
                <li class="bulletpoints">
                    <p><b>Taxonomy Logic:</b> <br>The function <span class="code-block-orange">handleElementTypeChange</span> ensures that when the user switches a button type, the tool automatically toggles state visibility based on support (e.g., hiding Loading states for a Select button), ensuring embedded knowledge is baked into the tool's core. </p>
                  </li>
              </div>

              <div class="bg__text-container">
                <li class="bulletpoints">
                  <p><b>Semantic Mapping:</b> <br>Functions like <span class="code-block-orange">getStatePseudoClass</span>  map user-friendly names such as <b>Selected / On</b> to the necessary CSS data attributes like <span class="code-block-orange">data-selected="true"</span> needed for styling the final output.</p>
                </li>
              </div>

            </div>



            <div id="section3" class="row width__s margin__auto padding__top-xl">
              <h2>Tool Logic & State Management</h2>
              <p class="divider-top">Moving beyond basic architecture, I defined the tool's core <b>operational logic</b>  (how it handles elements, effects, and feedback) to fully realize the Hybrid State Model. This required architecting specific data structures to handle the complexity of branded interaction.</p>

              <h3>1. Element Logic & Taxonomy</h3>
              <p>The core of the tool relies on a smart taxonomy system. Instead of treating all buttons the same, the code distinguishes behaviors via <span class="code-block-orange">elementType</span>.</p>
              
              <div class="ul-row orange__text-container">
                <ul>
                  <li class="bulletpoints">
                    <p><b>Logic:</b> <br>The function <span class="code-block-orange">handleElementTypeChange</span> actively manages state availability.</p>
                  </li><br><br>
                  <li class="bulletpoints">
                    <p><b>Embedded Knowledge:</b><br> For example, if a user switches a button from "Action" to "Select," the system automatically hides irrelevant states (like <code>Loading</code>) and enables specific ones (like <code>Selected</code>). This ensures the tool's interface adapts to the user's intent, embedding design knowledge directly into the logic.</p>
                  </li>
                </ul>
              </div>

              <h3 class="padding__top-l">2. Feedback as Modular Properties</h3>
              <p>To achieve high-fidelity "branded" feel, visual changes couldn't be simple CSS class toggles. I architected <span class="code-block-orange">stateFeedback</span> as a modular array system:</p>

              <div class="bg__text-container">
                <b>Stacking Logic</b><br><br>
                <p>Each state (e.g., <code>Hover</code>) contains an array of independent feedback objects (<code>Shape</code>, <code>Fill</code>, <code>Stroke</code>, <code>Effects</code>).</p><br>

                <b>Effect Management</b><br><br>
                
                <p>Complex properties like <b>Neumorphic shadows</b> or <b>Glows</b> are managed as specific objects within the feedback array (<span class="code-block-orange">addEffect</span>, <span class="code-block-orange">updateStateFeedback</span>). This allows users to stack multiple shadows or blend modes, which is essential for creating the "tactile" depth observed in my case studies.</p>
              </div>

              <h3 class="padding__top-l">3. The Hybrid State Machine</h3>
              <p>The most significant logical hurdle was handling compound states without overwhelming the user. I implemented a <b>Hybrid State Model</b>:</p>
              
              <div class="ul-row">
                <ul>
                  <li class="bulletpoints">
                    <p><b>Explicit States:</b> Visual states like <code>Rest</code>, <code>Hover</code>, and <code>Pressed</code> are explicitly defined.</p>
                  </li>
                  <li class="bulletpoints">
                    <p><b>Implicit Logic:</b> Conditional behaviors—such as whether a button stays pressed after release—are handled by boolean flags in the component logic (<span class="code-block-orange">stayInReleasedState</span>) rather than creating new, confusing state names. This keeps the UI clean while allowing the code to handle the complex state permutations required for Toggle and Selection buttons.</p>
                  </li>
                </ul>
              </div>

            </div>
            
            

            <div id="section4" class="row width__s margin__auto padding__top-xl ">
              <div class="column__no-content"></div>
              <div class="column">
                <h2>Next Steps</h2>
                
                <p class="divider-top margin__top-s padding__bottom-s">The next phase is stabilizing the new React implementation and adding functionality for <b>Transitions</b>, <b>Action</b>, <b>Code Preview & Export</b>, and <b>Presets</b>based on my previous research findings</p>

                <ul>
                    <li class="bulletpoints padding__bottom-s"><p><b>Debugging:</b> Debug the UI integration for the React in certain functions like cut off effects.</p></li>
                    <li class="bulletpoints padding__bottom-s"><p><b>More functions:</b> As now I built the basic tool's architecture and layout, I'll revisit my prototype from Figma to add more functionality to the tool such as code export and preview functions for implementation of the tool.</p></li>
                  </ul>


              </div>


              
            </div>

          </div>
        </section>
      </article>
    </main>

    <footer>
      <div class="scroll__top"><a href="javascript:scrollToTop();">↑</a></div>
      <div class="prev__next">
        <ul>
          <li class="prev"><a href="./week-12.html" id="go-prev">prev</a></li>
          <li><a href="../../index.html">overview</a></li>
          <li class="next"><a href="./week-14.html" id="go-next">next</a></li>
        </ul>
      </div>
    </footer>

    <div id="lightbox"></div>
    <script src="../../js/main.js"></script>
  </body>
</html>